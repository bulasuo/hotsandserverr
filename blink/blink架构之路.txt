 #define ***		重要且当前要完成
#define  **		次重要,但已经完成
#define ***<*	重要,且后期要去完成
#define #link?,	见第?条
#define c端		请求端

0.*** 服务器的设计规范:
	1) 

1.***用户注册只记录密码的MD5值<由于MD5的不可逆性 即使密码被盗,也不可能知道用户的原密码.>.

2.***client 对服务器每一次的请求必需带上userId和password(MD5)
这样可以防止没有权限的user操作其他user的数据<后期userId 可以写成服务器号+userid 为以后的服务器集群做准备!>

3.***如果请求是公开资源 可不用带上userId和password.

4.***对于需要权限的请求先到服务器查询id-password是否正确,否则到数据库查询,正确后把id-password保存到服务器运行环境下.
减轻数据库压力,<后期应该把这些id-password键值对保存到单独一个服务器<必要时这个服务器还应该是多个的,并且要及时做复制,减轻这个业务逻辑的压力>,因为对他们的查询比较频繁.>

5.**数据库表的设计要遵循 三个范式,表之间的副键可以在数据库就把数据的完整性验证了. 并且在表有唯一id的时候要设置改id唯一索引.

6.**对数据库的操作现在是直接服务器用sql直接操作数据库的,<后期应该是数据库与服务器权限分离,服务器只能通过数据库写好的存储过程来操作数据,并且要 提供权限即数据库用户,和数据权限:userId-password>在这里我们先简单点,但是还是要保证数据权限的安全#link2,3,

7.***<*对于c端的请求要做第一层过滤,防止恶意攻击,即做成网关,此时这个网关就是&link4,所说的键值对服务器.并且该网关还应该具备以下功能:
	1) 对请求要求有设备标识,要求记录ip,并且对改tags的请求做超频率过滤,且给返回原因.
	2) 满足第一条后,对需要数据权限的要对id-password键值对查询,权限是否合法.
	3) 把该请求转到适当的服务器,<集群所用>,#link0,4,服务器应该给网关传自己的服务器id

8.**服务器对数据库操作后,数据库的错误码应该反馈给服务器,服务器为了好调试应该传递给c端

9.***服务器应该做进程crash日志抓取并且邮件发送给developer. 并且要及时自动重启服务器. 先重启再发邮件.

10.***每个对数据库操作dao层的方法都要经过id-password合法性验证,合法性验证放到每个长连接线程中去,dao层的方法调用之前要经过权限合法性验证

11.*****传输协议:
	utf-8编码
	数据头 + 数据协议类型 + 数据类型 + 数据长度 + 数据(先string后n个图片) + 数据尾
	数据头:		-- + 边界符(36个字节) + \r\n				--40byte
	数据协议类型: (1byte)      0x01 :  一个string n个图片;;;    0xff:服务给客户端的RSA公钥 或者;;; 0xfe: 客户端给服务端的AES口令
	数据类型:	0x00: string; n: 图片byte[]		--<协议类型为0xff时省略>(2+n)byte 0为无,大于0为有,string大于0都默认只有一个string,文件n后跟nbyte依次表示后面文件的大小.
	数据长度:								--数据长度:	(int) n --4byte 跟在string 图片后面, 比如n个图片一个string  则为0x01 0x?? 0x?? 0x?? 0x?? (byte)n  n*(0x?? 0x?? 0x?? 0x??)
	数据:		json格式string; 图片byte[]		--nbyte
	数据尾:           -- + 边界符 + -- + \r\n			--42byte
	***单个图片不得超过100kb超过请先压缩; 不得超过10张图;
	*******只对AES秘钥进行RSA加密<客户端给服务端>,   只对JsonStr进行AES加密;
12.*******客户端与服务端的三次握手协议
	客户端发送连接请求
	服务端生成一对RSA秘钥对私钥保存到此次连接的线程中,并且公钥发给客户端
	客户端收到公钥,生成一个AES秘钥 用RSA公钥加密后发给服务端
	服务端收到ARS 秘钥后保存到 此次连接线程中,用于以后的传输的加密解密;
	PS:RSA是非对称加密算法效率低安全高,AES是对称加密算法,效率高,但安全相对低,因为被窃取后就会被模拟数据, 但是两者结合使用 即 ssh模式,比较高效安全

13.Socket接收的逻辑概述:
	每次都判断是不是数据头,否的话return,不进行下面的
	不是数据头则放到和并buffer

14.*********c/s架构 socket连接 策略
客户端5分钟定时向服务器发心跳包,好让服务器能及时联系客户端
客户端发送数据到服务器后要设置 超时机制,得到回应表示请求成功 把超时设置关闭,   如果超时后还没回应则socket重新连接服务器再发送上一次请求
	
15.服务端对短信验证码接口做限定ip60秒逻辑







PS:基于1-10,目前数据库的安全性完全取决于服务端所持有的数据库的用户密码,并且 服务器要做数据的操作权限管理

客户端设计:
	由于socket异步请求不像http一样是应答式的,所以客户端接收到服务端的数据后要根据action来做出反应
	**服务器给客户端发数据的response 的json里的tag会用客户端给的tag.客户端可以根据response的tag来唯一确定是哪一次的请求的回应.(建议用时间值唯一标示)
	

final

	后期要传密文不能传明文,形成链路的时候服务端给客户端一个公钥用以加密解密. 此方案替代安全链路.

	服务器端的接收数据解析是按格式收到多少解析多少,这样解析完成的可以丢掉,其实最多也就是丢掉jsonStr,而不是先把所有的都接收完再根据协议解析.  这样有利于减轻运存的压力

